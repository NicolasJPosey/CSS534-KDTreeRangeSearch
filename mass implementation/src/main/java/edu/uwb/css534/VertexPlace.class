// Source code is decompiled from a .class file using FernFlower decompiler.
package edu.uw.bothell.css.dsl.MASS;

import java.io.Serializable;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;
import java.util.stream.Collectors;

public class VertexPlace extends SmartPlace implements Serializable, Cloneable {
   static final long serialVersionUID = 4096L;
   protected Map<Object, Object> neighborResults;
   private Object[] graphArguments;
   public Vector<Object> neighbors = new Vector();
   public Vector<Object> weights = new Vector();
   public int left = -1;
   public int right = -1;

   public Object clone() throws CloneNotSupportedException {
      VertexPlace vertexClone = (VertexPlace)super.clone();
      vertexClone.neighbors = new Vector(this.neighbors.size());
      vertexClone.neighbors.addAll(this.neighbors);
      vertexClone.weights = new Vector(this.weights.size());
      vertexClone.weights.addAll(this.weights);
      if (this.graphArguments != null) {
         vertexClone.graphArguments = (Object[])this.graphArguments.clone();
      }

      if (this.neighborResults != null) {
         vertexClone.neighborResults = new HashMap(this.neighborResults.size());
         vertexClone.neighborResults.putAll(this.neighborResults);
      }

      return vertexClone;
   }

   public void prepareForExchangeAll() {
      this.neighborResults = new HashMap(this.neighbors.size());
   }

   public void addNeighbor(Object neighborId, double weight) throws IllegalArgumentException {
      if (!this.neighbors.contains(neighborId)) {
         this.neighbors.add(neighborId);
         this.weights.add((int)Math.round(weight));
      }
   }

   public void removeNeighbor(Object neighborId) throws IllegalArgumentException {
      if (!this.neighbors.contains(neighborId)) {
         throw new IllegalArgumentException("Invalid neighbor for remove: " + neighborId);
      } else {
         int index = this.neighbors.indexOf(neighborId);
         this.neighbors.remove(neighborId);
         this.weights.remove(index);
      }
   }

   public void setNeighborResult(Object neighbor, Object result) {
      int neighborIndex = this.neighbors.indexOf(neighbor);
      this.neighborResults.put(neighborIndex, result);
   }

   public void removeNeighborSafely(Object neighborVertexId) {
      if (this.neighbors != null && this.neighbors.contains(neighborVertexId)) {
         this.removeNeighbor(neighborVertexId);
      }

   }

   public Object[] getNeighbors() {
      Object[] result = new Object[this.neighbors.size()];

      for(int i = 0; i < result.length; ++i) {
         result[i] = this.neighbors.get(i);
      }

      return result;
   }

   public Object[] getWeights() {
      Object[] result = new Object[this.weights.size()];

      for(int i = 0; i < result.length; ++i) {
         result[i] = this.weights.get(i);
      }

      return result;
   }

   public VertexPlace() {
      MASSBase.getLogger().debug("VertexPlace constructed.");
   }

   public VertexPlace(Object args) {
      try {
         if (args != null) {
            Object[] arguments = (Object[])args;
            this.graphArguments = Arrays.copyOfRange(arguments, 0, 3);
            this.setIndex(new int[]{(Integer)this.graphArguments[2]});
            this.init(args);
            MASSBase.getLogger().trace(String.format("VertexPlace constructed with args: { id: %d, neighbors: [%s], weights: [%s] }\n", this.graphArguments[2], this.neighbors.stream().map((n) -> {
               return n.toString();
            }).collect(Collectors.joining(", ")), this.weights.stream().map((w) -> {
               return w.toString();
            }).collect(Collectors.joining(", "))));
         }
      } catch (Exception var3) {
         MASSBase.getLogger().error("Exception in VertexPlace constructor", var3);
      }

   }

   private void init(Object args) {
      Object[] arguments = (Object[])args;
      this.graphArguments = Arrays.copyOfRange(arguments, 0, 3);
   }

   public Object getAttribute() {
      return MASSBase.distributed_map.get(this.getIndex()[0]);
   }
}
